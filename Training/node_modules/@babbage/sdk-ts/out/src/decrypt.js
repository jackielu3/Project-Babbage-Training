"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decryptAsArray = exports.decryptAsString = exports.decrypt = void 0;
const connectToSubstrate_1 = __importDefault(require("./utils/connectToSubstrate"));
/**
 * Decrypts data with a key belonging to the user.
 * The same protocolID, keyID, counterparty and privileged parameters that were used during encryption
 * must be used to successfully decrypt.
 *
 * @param {Object} args All parameters are passed in an object.
 * @param {string|Uint8Array} args.ciphertext The encrypted data to decipher.
 * If given as a string, it must be in base64 format.
 * @param {ProtocolID} args.protocolID Specify an identifier for the protocol
 * under which this operation is being performed.
 * It should be the same protocol ID used during encryption.
 * @param {string} args.keyID This should be the same message ID used during encryption.
 * @param {string} [args.description] Describe the high-level operation being performed,
 * so that the user can make an informed decision if permission is needed.
 * @param {Uint8Array|string} [args.counterparty=self] If a foreign user used the local user's
 * identity key as a counterparty when encrypting a message,
 * specify the foreign user's identity key and the message can be decrypted.
 * Must be a hexadecimal string representing a 33-byte or 65-byte value, "self" or "anyone".
 * @param {Boolean} [args.privileged=false] This indicates which keyring should be used when decrypting.
 * Use the same value as was used during encryption.
 * @param {string} [args.returnType=Uint8Array] Specify the data type for the returned plaintext.
 * Available types are `string` (TextDecoder decoded) and `Uint8Array`.
 *
 * @returns {Promise<string|Uint8Array>} The decrypted plaintext.
 */
async function decrypt(args) {
    const connection = await (0, connectToSubstrate_1.default)();
    const r = await connection.dispatch({
        name: 'decrypt',
        params: {
            ciphertext: typeof args.ciphertext === 'string'
                ? Uint8Array.from(Buffer.from(args.ciphertext, 'base64'))
                : args.ciphertext,
            protocolID: args.protocolID,
            keyID: args.keyID,
            description: args.description || '',
            counterparty: args.counterparty || 'self',
            privileged: args.privileged || false,
            returnType: 'Uint8Array'
        },
        bodyParamKey: 'ciphertext',
        contentType: 'application/octet-stream'
    });
    if (args.returnType !== 'string')
        return r;
    return new TextDecoder().decode(r);
}
exports.decrypt = decrypt;
/**
 * Decrypts data with a key belonging to the user.
 * The same protocolID, keyID, counterparty and privileged parameters that were used during encryption
 * must be used to successfully decrypt.
 *
 * @param {Object} args All parameters are passed in an object.
 * @param {string|Uint8Array} args.ciphertext The encrypted data to decipher.
 * If given as a string, it must be in base64 format.
 * @param {ProtocolID} args.protocolID Specify an identifier for the protocol
 * under which this operation is being performed.
 * It should be the same protocol ID used during encryption.
 * @param {string} args.keyID This should be the same message ID used during encryption.
 * @param {string} [args.description] Describe the high-level operation being performed,
 * so that the user can make an informed decision if permission is needed.
 * @param {Uint8Array|string} [args.counterparty=self] If a foreign user used the local user's
 * identity key as a counterparty when encrypting a message,
 * specify the foreign user's identity key and the message can be decrypted.
 * Must be a hexadecimal string representing a 33-byte or 65-byte value, "self" or "anyone".
 * @param {Boolean} [args.privileged=false] This indicates which keyring should be used when decrypting.
 * Use the same value as was used during encryption.
 *
 * @returns {Promise<string>} The decrypted plaintext TextDecoder decoded to string.
 */
async function decryptAsString(args) {
    return decrypt({
        ...args,
        returnType: 'string'
    });
}
exports.decryptAsString = decryptAsString;
/**
 * Decrypts data with a key belonging to the user.
 * The same protocolID, keyID, counterparty and privileged parameters that were used during encryption
 * must be used to successfully decrypt.
 *
 * @param {Object} args All parameters are passed in an object.
 * @param {string|Uint8Array} args.ciphertext The encrypted data to decipher.
 * If given as a string, it must be in base64 format.
 * @param {ProtocolID} args.protocolID Specify an identifier for the protocol
 * under which this operation is being performed.
 * It should be the same protocol ID used during encryption.
 * @param {string} args.keyID This should be the same message ID used during encryption.
 * @param {string} [args.description] Describe the high-level operation being performed,
 * so that the user can make an informed decision if permission is needed.
 * @param {Uint8Array|string} [args.counterparty=self] If a foreign user used the local user's
 * identity key as a counterparty when encrypting a message,
 * specify the foreign user's identity key and the message can be decrypted.
 * Must be a hexadecimal string representing a 33-byte or 65-byte value, "self" or "anyone".
 * @param {Boolean} [args.privileged=false] This indicates which keyring should be used when decrypting.
 * Use the same value as was used during encryption.
 *
 * @returns {Promise<Uint8Array>} The decrypted plaintext.
 */
async function decryptAsArray(args) {
    return decrypt({
        ...args,
        returnType: 'string'
    });
}
exports.decryptAsArray = decryptAsArray;
exports.default = decrypt;
//# sourceMappingURL=decrypt.js.map