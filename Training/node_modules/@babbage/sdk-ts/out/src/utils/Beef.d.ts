import { MerklePath, Transaction, Utils, ChainTracker } from "@bsv/sdk";
export declare const BEEF_MAGIC = 4022206465;
export declare const BEEF_MAGIC_KNOWN_TXID_EXTENSION = 4022206465;
export declare class BeefTx {
    _bumpIndex?: number;
    _tx?: Transaction;
    _rawTx?: number[];
    _txid?: string;
    known: boolean;
    inputTxids: string[];
    degree: number;
    get bumpIndex(): number | undefined;
    set bumpIndex(v: number | undefined);
    get txid(): string;
    get tx(): Transaction | undefined;
    get rawTx(): number[] | undefined;
    constructor(tx: Transaction | number[] | string, bumpIndex?: number);
    updateInputTxids(): void;
    toWriter(writer: Utils.Writer): void;
    static fromReader(br: Utils.Reader): BeefTx;
}
export declare class Beef {
    bumps: MerklePath[];
    txs: BeefTx[];
    constructor();
    /**
     * Merge a MerklePath that is assumed to be fully valid.
     * @param bump
     * @returns index of merged bump
     */
    mergeBump(bump: MerklePath): number;
    /**
     * Merge a serialized transaction.
     *
     * Checks that a transaction with the same txid hasn't already been merged.
     *
     * Replaces existing transaction with same txid.
     *
     * @param rawTx
     * @returns txid of rawTx
     */
    mergeRawTx(rawTx: number[]): string;
    /**
     * Merge a `Transaction` and any referenced `merklePath` and `sourceTransaction`, recursifely.
     *
     * Replaces existing transaction with same txid.
     *
     * Attempts to match an existing bump to the new transaction.
     *
     * @param tx
     * @returns txid of tx
     */
    mergeTransaction(tx: Transaction): string;
    removeExistingTxid(txid: string): void;
    mergeKnownTxid(txid: string): void;
    mergeBeef(beef: number[] | Beef): void;
    /**
     * Sorts `txs` and checks structural validity of beef.
     *
     * Validity requirements:
     * 1. No 'known' txids, unless `allowKnown` is true.
     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).
     * 3. Order of transactions satisfies dependencies before dependents.
     * 4. No transactions with duplicate txids.
     *
     * @param allowKnown optional. If true, transaction txid is assumed valid
     * @param chainTracker optional. If defined, used to verify computed merkle path roots for all bump txids.
     */
    isValid(allowKnown?: boolean): boolean;
    /**
     * Sorts `txs` and confirms validity of transaction data contained in beef
     * by validating structure of this beef and confirming computed merkle roots
     * using `chainTracker`.
     *
     * Validity requirements:
     * 1. No 'known' txids, unless `allowKnown` is true.
     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).
     * 3. Order of transactions satisfies dependencies before dependents.
     * 4. No transactions with duplicate txids.
     *
     * @param chainTracker Used to verify computed merkle path roots for all bump txids.
     * @param allowKnown optional. If true, transaction txid is assumed valid
     */
    verify(chainTracker: ChainTracker, allowKnown?: boolean): Promise<boolean>;
    private verifyValid;
    toBinary(): number[];
    toHex(): string;
    static fromReader(br: Utils.Reader): Beef;
    static fromBinary(bin: number[]): Beef;
    static fromString(s: string, enc?: 'hex' | 'utf8' | 'base64'): Beef;
    /**
     * Try to validate newTx.bumpIndex by looking for an existing bump
     * that proves newTx.txid
     *
     * @param newTx A new `BeefTx` that has been added to this.txs
     * @returns true if a bump was found, false otherwise
     */
    tryToValidateBumpIndex(newTx: BeefTx): boolean;
    /**
     * Sort the `txs` by input txid dependency order.
     * @returns array of input txids of unproven transactions that aren't included in txs.
     */
    sortTxs(): string[];
    toLogString(): string;
}
//# sourceMappingURL=Beef.d.ts.map